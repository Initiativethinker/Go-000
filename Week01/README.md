### RPC协议综述

+ 问题背景

  ​	虚拟化技术解决了物理资源的伸缩以及灵活的分配实现了物理层上的封装。容器技术实现了软件应用层上的封装，在容器中，用户可以部署软件应用服务。有了物理机器提供计算支持，有了软件应用的封装可以实现灵活的调用业务服务，那么如何实现远程程序调用成为了一个问题？

+ Remote Procedure Calls (RPC)

  远程程序调用是一个大牛专门编写的协议规范和处理流程，主要用于解决服务远程调用的协议问题、传输问题、服务发现问题。简化一下问题，若想要远程地调用一个函数，我们必须解决以下五个问题

  + 如何规定远程调用的语法？

    不同程序语言的语法规则不同，为了兼容不同语言的调用，RPC需要设计自己的语法规则，为了让客户端和服务端对带调用函数的表述一致，必须双方都清楚语法规则，即语言相通。

  + 如何传递参数？

    服务调用终归还是API调用，那么如何传递API的参数呢？参数从哪里开始到哪里结束呢？

  + 如何表示数据？

    参数中肯定要数据，不同语言和计算机架构中对于不同数据类型的长度是不同的，那么RPC如何表示数据才能保证数据传输的一致性呢？

  + 如何知道一个服务端有哪些远程调用，从那个端口可以访问这个远程调用？

    一个服务端有多个应用可以远程调用，每个应用可能实现在不同的进程，每个进程监听的端口也不同，由于多个应用部署在同一个机器上，为了防止冲突，往往使用随机端口，客户端如何寻找这些监听端口呢？

  + 如果发生错误、重传、丢包、性能等问题怎么办？

    远程传输调用的参数时候，如果传输的内容出错如何进行处理！

  远程调用程序未解决上述问题提供下面框架式的解决方案

  ![img](https://static001.geekbang.org/resource/image/85/25/8534c52daf3682cd1cfe5a3375ec9525.jpg)

  + 实际上也分为三层，应用层--负责调用，中间层--负责编解码数据请求等， 传输层--负责传送数据包

---

### Go架构实践-微服务(微服务概览与治理)

+ 微服务概览

  + 微服务起源

    ​	微服务围绕业务（最终目的）功能构建的服务，该服务关注单一业务（特点），服务间采用轻量级通信机制（特点），可以全自动独立部署（关键特性），可以使用不同的编程语言和数据存储技术。

    + 小即使美：小的服务代码少，bug少，易测试，易维护
    + 单一职责：一个服务也只需要做好一件事
    + 尽可能早地创建原型：尽可能早的提供服务API，建立服务契约，达成服务间的沟通一致性约定，实现和完善可以慢慢在做。
    + 可移植性比效率更重要：服务间的轻量级交互协议在效率和可移植性二者之间，首要依然考虑兼容性和移植性

  + 微服务定义

    微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活，其主要特点有：

    + 原子服务--服务关注单一业务
    + 独立进程--资源隔离
    + 隔离部署
    + 去中心化治理---减少系统性崩溃的风险

    缺点：

    + 基础设施的建设、复杂度高---相互联调的复杂性增高

  + 微服务不足

    + 微服务应用是分布式系统，由此会带来固有的复杂性。**开发者不得不使用RPC或者消息传递，来实现进程间通信**。此外，必须要写代码处理消息传递中速度过慢或者服务不可用等局部失效问题。
    + 分区的数据库架构，由于每个微服务又个独立的DB，分布式的一致性问题
    + 测试一个基于微服务架构的应用也是很复杂的任务
    + 服务模块间的依赖，应用升级有可能会波及多个服务模块的修改
    + 对运维基础设施的挑战比较大

  + 组件服务化

    传统的组件化，是通过将库library和应用一起部署，库局部发生变化，整个应用服务需要重新部署。换一种新的思路，以服务为中心来实现组件，即将一个应用拆分为一系列的服务，**这些服务运行在不同的进程中**，**单一局部服务的变化只需要重新部署对应的服务进程**。Go实施一个微服务，分为以下几个方面

    + Kit ： 一个微服务的基础库(框架)
    + service：业务代码 + kit依赖 + 第三方依赖组成的业务微服务
    + Rpc + message queue ： 轻量级通讯---异步通信--Kafka

    **本质上等同于，多个微服务组合完成一个完整的用户场景**

  + 按业务组织服务

    服务必须与业务功能相对应，开发团队对软件在生产环节的运行负全部责任！！

  + 去中心化

    按照业务来组织服务，但是不同的业务根据业务场景不同即使使用同一服务也有细微的差别，通过去中心化的方式来实现业务服务的个性化以及隔离

    + 数据去中心化----各个服务拥有自己的DB
    + 治理去中心化---服务的中心节点(热点)
    + 技术去中心化

  + 基础设施自动化

    单一进程的传统应用被拆分为一系列多进程服务后，开发、调试、监控和部署的复杂度指数增加。

  + 可用性&兼容性设计

    设计部署的微服务必须满足可用性，同时为了方便组合部署，也要实现兼容性设计。最著名的思想便是Design For Failure ，由于微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题。忽略其中任何一点都属于对“分布式计算的误解”

    + 隔离
    + 超时控制
    + 负载保护
    + 限流
    + 降级
    + 重试
    + 负载均衡

    一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约(接口)的兼容性

+ 微服务设计

  即然对外界提供服务，那么外界如何调用服务即如何调用API，那么API的设计是微服务设计的关键点之一。

  + API Gateway---前端轻、后端重

    ![image-20201120165506732](/Users/liuchenjianshu/Library/Application Support/typora-user-images/image-20201120165506732.png)

    垂直功能进行拆分，对外直接暴露微服务接口，带来的问题有很多

    + 客户端与服务端直接通信，高度耦合，服务端的更改客户端必须更上，耦合性太高，牵一发而动全身
    + 客户端需要对后端发出多次请求，业户巨大，延迟高
    + 客户端要对不同的后端服务提供协议，协议不统一，兼容性差
    + 客户端的终端不同，访问协议接口不同，每个服务都要分别处理来自不同终端的请求
    + 没有中心节点，安全认证，授权如何处理。

    最直接的解决方案便是内聚配合

    ![image-20201122101330880](/Users/liuchenjianshu/Library/Application Support/typora-user-images/image-20201122101330880.png)

    + 客户端只需要和网关小组进行对接
    + 网关小组向上提供API支持，向下的业务可以兼容升级，升级的是内容而不是协议
    + 最致命的问题就是高可用问题，如果网关故障了，整个服务都会消失

    ![image-20201122105733886](/Users/liuchenjianshu/Library/Application Support/typora-user-images/image-20201122105733886.png)

    + 当把业务横向拆解成多个BFF，拆解的模块越多代码越复杂
    + 解决思路是再次引入一层API 网关，BFF只关注于业务

    ![image-20201122110857827](/Users/liuchenjianshu/Library/Application Support/typora-user-images/image-20201122110857827.png)

  + 微服务划分

    + Business Capability---业务职能进行拆分
    + Bounded Context---限界上下文--按照业务进行划分

+ gRPC&服务发现

  + GoogleRPC frame work 用一句话概括

    A high performance ,open-source universal RPC framework

    + 多语言：语言中立，支持大量语言
    + 轻量级、高性能：序列化支持PB(Protocol Buffer)和JSON，使用PB这种高性能语言框架序列化框架，方便读取调用
    + IDL：基于文件定义服务，通过proto3工具生产指定的语言结构，服务接口，客户端Stub从而实现对消息的定制化编解码
    + 移动端：基于标准的HTTP2设计，支持双向流、消息头压缩、单TCP多路复用，服务推送等特性，这些特性使得gRPC在移动端更加节能。

    ![image-20201122125427319](/Users/liuchenjianshu/Library/Application Support/typora-user-images/image-20201122125427319.png)

    ![image-20201122130158308](/Users/liuchenjianshu/Library/Application Support/typora-user-images/image-20201122130158308.png)

  + gRPC的健康检查

    ![image-20201122131739548](/Users/liuchenjianshu/Library/Application Support/typora-user-images/image-20201122131739548.png)

    + 消费者定期检查服务，当服务可用时候，被消费者感知，从负载均衡中删除，将资源空出来给其他服务
    + 方便平滑发布，发布一个新的服务，通过健康检查判断服务是否可用，从而使该服务重新加入到负载均衡中
    + 方便平滑退出，当下掉一个服务的时候，会通知其他所有的消费者，消费者知晓后再逐步退出服务，因为通过健康检查来退出，不会过于迅猛。

  + 服务发现-客户端发现可用的微服务

    一个服务实例启动时，它的网络地址会被写到注册表上；当服务实例终止时，再从注册表中删除；这个服务实例的注册表通过心跳机制动态刷新；客户端使用一个负载均衡算法，去选择一个可用的服务实例，来响应这个请求。

    中心化太严重，如果注册表无法找到或者及时更新，会产生无法调用服务的错误

  + 服务发现--服务端发现

    客户端通过负载均衡器向一个服务发送请求，这个负载均衡器会查询服务注册表，并将请求路由到可用的服务实例上。服务实例在服务注册表上被注册和注销。

    ![image-20201122134502286](/Users/liuchenjianshu/Library/Application Support/typora-user-images/image-20201122134502286.png)

    但是通常一个LB是不够的，如果有多个LB，那么需要多个IP地址，服务端访问也要通过访问多个IP地址，可以使用Linux virtual Server，将多个LB进行打包，对外只公开一个IP

+ 多集群&多租户